package com.lbq.concurrent.chapter13;

import java.util.concurrent.CountDownLatch;
/**
 * 13.1 并发编程的三个重要特性
 * 并发编程有三个至关重要的特性，分别是原子性、有序性和可见性，理解这三个特征对于开发正确的高并发程序会有很大的帮助。
 * 13.1.1 原子性
 * 所谓原子性是指在一次的操作或者多次操作中，要么所有的操作全部都都到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。
 * 说起原子性一般都会用银行转账来进行举例说明，比如从Alex的账号往Tina的账号转入1000元，这个动作将包含两个最基本的操作：
 * 从Alex的账号上扣除1000元；给Tina的账号增加1000元。这两个操作必须符合原子性的要求，要么都成功要么都失败，
 * 总之不能出现Alex的账号扣除了1000元，但是Tina账号并未增加1000元或者Alex账号未扣除1000元，Tina的账号反倒增加了1000元的情况。
 * 
 * 同样在我们编写代码的过程中，比如一个简单的赋值语句：Object o = new Object();
 * 引用类型o占用四个字节(32位)，假设这样的赋值语句不能保证原子性的话，那么会导致赋值出现错误的数据。
 * 注意：两个原子性的操作结合在一起未必还是原子性的，比如i++(其中get i, i+1, set i = x三者皆是原子性操作，但是不代表i++就是原子性操作)。
 * volatile关键字不保证数据的原子性，synchronized关键字保证，自JDK1.5版本起，其提供的原子类型变量也可以保证原子性。
 * 
 * 13.1.2 可见性
 * 可见性是指，当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值，
 * 根据12.2节的分析，Reader线程会将init_value从主内存缓存到CPU Cache中，也就是从主内存缓存到线程的本地内存中，
 * Updater线程对init_value的修改对Reader线程是不可见的。
 * 
 * 13.1.3 有序性
 * 所谓有序性是指程序代码在执行过程中的先后顺序，由于Java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序，比如：
 * int x = 10;
 * int y = 0;
 * x++;
 * y = 20;
 * 上面这段代码定义了两个int类型的变量x和y，对x进行自增操作，对y进行赋值操作，从编写程序的角度来看上面的代码肯定是顺序执行下来的，
 * 但是在JVM真正地运行这段代码的时候未必会是这样的顺序，比如y=20语句有可能会在x++语句的前面得到执行，
 * 这种情况就是我们通常所说的指令重排序（Instruction Recorder）。
 * 一般来说，处理器为了提高程序的运行效率，可能会对输入的代码指令做一定的优化，他不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序类进行，
 * 但是它会保证程序的最终运算结果是编写时所期望的那样，比如上文中的x++与y=20不管它们的执行顺序如何，执行完上面的四行代码之后得到的结果肯定都是x=11,y=20。
 * 
 * 当然对指令的重排序要严格遵守指令之间的数据依赖关系，并不是可以任意进行重排序的，比如下面的代码片段：
 * int x = 10;
 * int y = 0;
 * x++;
 * y=x+1;
 * 对于这段代码有可能它的执行顺序就是代码本身的顺序，有可能发生了重排序导致int y = 0 优先于int x = 10执行，但是绝对不可能出现y = x + 1优先于x++执行情况，
 * 如果一个指令x在执行的过程中需要用到指令y的执行结果，那么处理器会保证指令y在指令x之前执行，这就好比y=x+1执行之前肯定要先执行x++一样。
 * 
 * 在单线程情况下，无论怎样的重排序最终都会保证程序的执行结果和代码顺序执行的结果是完全一致的，但是在多线程的情况下，如果有序性得不到保证，那么很有可能就会出现非常大的问题，
 * 比如下面的代码片段：
 * private boolean initialized = false;
 * private Context context;
 * public Context load(){
 * 		if(!initialized){
 * 			context = loadContext();
 * 			initialized = true;
 * 		}
 * 		return context;
 * }
 * 上述这段代码使用boolean变量initialized来控制context是否已经被加载过了，在单线程下无论怎样的重排序，最终返回给使用者的context都是可用的。
 * 如果在多线程的情况下发生了重排序，比如context = loadContext()的执行被重排序到了initialized = true的后面，那么这将是灾难性的了。
 * 比如第一个线程首先判断到initialized=false，因此准备执行context的加载，但是它在执行loadContext()方法之前二话不说先将initialized置为true
 * 然后再执行loadContext()方法，那么如果另外一个线程也执行load方法，发现此时initialized已经为true了，则直接返回一个还未被加载成功的context，
 * 那么在程序的运行过程中势必会出现错误。
 * 
 * 13.2 JMM如何保证三大特性
 * 		我们在13.1节中比较详细地介绍了高并发编程需要保证的三大主要特性，这对并发程序正确的运行有着至关重要的作用。
 * 在本节中，我们将结合Java的内存模型来看看在Java的世界中，是通过何种方式来保证原子性、可见性和顺序性这三大特性的。
 * 		JVM采用内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下到达一致的内存访问效果，
 * 比如C语言中的整型变量，在某些平台下占用了两个字节的内存，在某些平台下则占用了四个字节的内存，
 * Java则在任何平台下，Int类型就是四个字节，这就是所谓的一致内存访问效果。
 * Java的内存模型规定了所有的变量都是存在于主内存(RAM)当中的，而每个线程都有自己的工作内存或者本地内存(这一点很像CPU的Cache)，
 * 线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存。
 * 		比如在某个线程中对变量i的赋值操作i=1，该线程必须在本地内存中对i进行修改之后才能将其写入主内存之中。
 * 
 * 13.2.1 JMM与原子性
 * 		在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，
 * 因此诸如此类的操作是不可被中断的，要么执行，要么不执行，正所谓一荣俱荣一损俱损。
 * 		不过话虽如此简单，但是理解起来未必不会出错，下面我们就来看几个例子。
 * (1)x=10;赋值操作
 * x=10的操作是原子性的，执行线程首先会将x=10写入工作内存中，然后再将其写入主内存中
 * （有可能在往主内存进行数值刷新的过程中其他线程也在对其进行刷新操作，比如另外一个线程将其写为11，但是最终的结果肯定要么是10，要么是11，
 * 不可能出现其他情况，单就赋值语句这一点而言是原子性的）。
 * (2)y=x;赋值操作
 * 这条操作语句是非原子性的，因为它包含如下两个重要的步骤。
 * 1)执行线程从主内存中读取x的值（如果x已经存在与执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中。
 * 2)在执行线程的工作内存中修改y的值为x，然后将y的值写入主内存之中。
 * 虽然第一步和第二步都是原子类型的操作，但是合在一起就不是原子操作了。
 * (3)y++;自增操作
 * 这条操作语句是非原子性的，因为它包含三个重要的步骤，具体如下。
 * 1)执行线程从主内存中读取y的值（如果y已经存在与执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中。
 * 2)在执行线程工作内存中为y执行加一操作。
 * 3)将y的值写入主内存。
 * (4)z=z+1;加一 操作(与自增操作等价)
 * 这条操作语句是非原子性的，因为它包含三个重要的步骤，具体如下。
 * 1)执行线程从主内存中读取z的值（如果z已经存在与执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中。
 * 2)在执行线程工作内存中为z执行加一操作。
 * 3)将z的值写入主内存。
 * 		综合上面的四个例子，我们可以发现只有第一种操作即赋值操作具备原子性，其余的均不具备原子性，由此我们可以得出以下几个结论。
 * 1.多个原子性的操作在一起就不再是原子性操作了。
 * 2.简单的读取与赋值操作是原子性的，将一个变量赋给另外一个变量的操作不是原子性的。
 * 3.Java内存模型(JMM)只保证了基本读取和赋值的原子性操作，其他的均不保证，如果想要使得某些代码片段具备原子性，
 * 需要使用关键字synchronized，或者JUC包下的原子封装类型java.util.concurrent.atomic.*
 * 总结：volatile关键字不具备保证原子性的语义。
 * 
 * 13.2.2 JMM与可见性
 * 		在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存种获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。
 * 同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中。但是什么时候最新的值会被刷新至主内存中是不太确定的，
 * 这也就解释了为什么VolatileFoo中的Reader线程始终无法获取到init_value最新的变化。
 * 		Java提供了以下三种方式来保证可见性。
 * 1.使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到工作内存中，
 * 当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），
 * 对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立刻将其刷新到主内存中。
 * 2.通过synchronized关键字能够保证 可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，
 * 并且还会确保在锁释放之前，会将对变量得修改刷新到主内存当中。
 * 3.通过JUC提供的显示锁Lock也能够保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁，然后执行同步方法，
 * 并且会确保在锁释放(Lock的unlock方法)之前会将对变量的修改刷新到主内存当中。
 * 		总结：volatile关键字具有保证可见性的语义。
 * 
 * 13.2.3 JMM与有序性
 * 		在Java的内存模型中，允许编译器和处理器对指令进行重排序，在单线程的情况下，重排序并不会引起什么问题，
 * 但是在多个线程的情况下，重排序会影响到程序的正确运行，Java提供了三种保证有序性的方式，具体如下。
 * 1.使用volatile关键字来保证有序性。
 * 2.使用synchronized关键字来保证有序性。
 * 3.使用显式锁Lock来保证有序性。
 * 		后两者采用了同步的机制，同步代码在执行的时候与在单线程情况下一样自然能够顺序性（最终结果的顺序性），
 * 对于volatile关键字我们在13.3节中还会进行更加详细的介绍。
 * 		此外，Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能保证有序性，这个规则被称为Happens-before原则。
 * 如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就无法保证有序性，也就是说虚拟机或者处理器可以随意对它们进行重排序处理。
 * 下面我们来具体看看都有哪些happens-before原则。
 * 1.程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。
 * 这句话的意思看起来是程序按照编写的顺序来执行的，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。
 * 2.锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作。
 * 这句话的意思是，无论是在单线程还是在多线程的环境下，如果同一个锁是锁定状态，那么必须先对其执行释放操作之后才能继续进行lock操作。
 * 3.volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作。
 * 根据字面的意思来理解是，如果一个变量使用volatile关键字修饰，一个线程对它进行读操作，一个线程对它进行写操作，那么写入操作肯定要先行发生于读操作，
 * 关于这个规则我们在13.3节中还会继续介绍。
 * 4.传递规则：如果操作A先于操作B，而操作B又先于操作C，则可以得出操作A肯定要先于操作C，这一点说明了happends-before原则具备传递性。
 * 5.线程启动规则：Thread对象的start()方法先行发生于对该线程的任何动作，这也是我们在第一部分中讲过的，只有start之后线程才能真正运行，否则Thread也只是一个对象而已。
 * 6.线程中断规则：对线程执行interrupt()方法肯定要优先于捕获到中断信号，这句话的意思是指如果线程收到了中断信号，那么在此之前势必要有interrupt()。
 * 7.线程的终结规则：线程中所有的操作都要先行发生于线程的终止检测，通俗地讲，线程的任务执行、逻辑单元执行肯定要发生于线程死亡之前。
 * 8.对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前，这个更没什么好说的了，先有生后有死。
 * 		总结：volatile关键字具有保证顺序性的语义。
 * 
 * 13.3 volatile关键字深入解析
 * 		将近两个章节的内容介绍，其实都是为volatile关键字做铺垫，没有完全孤立存在的知识，只有通过某个点将一些相关性的知识串联起来才能够形成一个知识体系，
 * 以助于理解和记忆，这也是为什么我们长篇大论了一番才切入正题讲解volatile关键字的原因。
 * 
 * 13.3.1 volatile关键字的语义
 * 		被volatile修饰的实例变量或者类变量具备如下两层语义。
 * 1.保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另外一个线程会立即看到最新的值。
 * 2.禁止对指令进行重排序操作。
 * (1)理解volatile保证可见性
 * 		关于共享变量在多线程间的可见性，在VolatileFoo例子中已经体现得非常透彻了，Update线程对init_value变量的每一次更改都会使得Reader线程能够看到
 * （在happens-before规则中，第三条volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作），其步骤具体如下。
 * 1)Reader线程从主内存中获取init_value的值为0，并且将其缓存到本地工作内存中。
 * 2)Updater线程将init_value的值在本地工作内存中修改为1，然后立即刷新至主内存中。
 * 3)Reader线程在本地工作内存中的init_value失效(反映到硬件上就是CPU的L1或L2的Cache Line失效)。
 * 4)由于Reader线程工作内存中的init_value失效，因此需要到主内存中重新读取init_value的值。
 * 		经过上面几个步骤的分析，相信读者对volatile关键字保证可见性有了一个更加清晰的认识了。
 * (2)理解volatile保证顺序性
 * 		volatile关键字对顺序性的保证就比较霸道一点，直接禁止JVM和处理器对volatile关键字修饰的指令重排序，
 * 但是对于volatile前后无依赖关系的指令则随便怎么排序，比如
 * int x = 0;
 * int y = 1;
 * volatile int z = 20;
 * x++;
 * y--;
 * 在语句volatile int z = 20之前，先执行x的定义还是先执行y的定义，我们并不关心，
 * 只要百分之百地保证在执行到z=20的时候x=0，y=1，同理关于x的自增已经y的自减操作都必须在z=20以后才能发生。
 * 
 * 再回到关于load context的那个例子，如果对initialized布尔变量增加了volatile的修饰，
 * 那就意味着initialized=true的时候一定是执行且完成了对loadContext()方法调用，代码如下：
 * private volatile boolean initialized = false;
 * private Context context;
 * public Context load(){
 * 		if(!initialized){
 * 			context = loadContext();
 * 			initialized = true;//阻止重排序
 * 		}
 * 		return context;
 * }
 * 
 * (3)理解volatile不保证原子性
 * 		我们已经不止一次地说过了，volatile关键字不保证操作的原子性，在这里我们结合JMM的知识分析一下其中的原因，
 * 比如下面的这段代码：VolatileTest.class
 * 上面这段代码创建了10个线程，每个线程执行1000次对共享变量i的自增操作，但是最终的结果i肯定不是10000，而且每次运行的结果也是各不相同，
 * 下面来分析一下其中的原因。
 * i++的操作其实是由三步组成的，具体如下：
 * 1)从主内存中获取i的值，然后缓存至线程工作内存中。
 * 2)在线程工作内存中为i进行加1的操作。
 * 3)将i的最新值写入主内存中。
 * 上面三个操作单独的每一个操作都是原子性操作，但是合起来就不是，因为在执行的中途很可能会被其他线程打断，例如如下操作情况。
 * 1)假设此时i的值为100，线程A要对变量i执行自增操作，首先它需要到主内存中读取i的值，可是此时由于CPU时间片调度的关系，执行权切换到了线程B，A线程进入了Runnable状态而不是running状态。
 * 2)线程B同样需要从主内存中读取i的值，由于线程A没有对i做过任何修改操作，因此此时B获取到的i仍然是100。
 * 3)线程B工作内存中为i执行了加1操作，但是未刷新至主内存中。
 * 4)CPU时间片的调度又将执行权给了线程A，A线程直接对工作内存中的100进行加1运算（因为A线程已经从主内存中读取了i的值），由于B线程并未写入i的最新值，因此A线程工作内存中的100不会被失效。
 * 5)线程A将i=101写入到主内存之中。
 * 6)线程B将i=101写入到主内存之中。
 * 这样，两次运算实际上只对i进行了一次数值的修改变化。
 * 
 * 13.3.2 volatile的原理和实现机制
 * 经过前面内容的学习，我们知道了volatile关键字可以保证可见性以及顺序性，那么它到底是如何做到的呢？
 * 通过对OpenJDK下unsafe.cpp源码的阅读，会发现被volatile修饰的变量存在于一个“lock;”的前缀，源码如下：
 * //Adding a lock prefix to an instruction on MP machine
 * #define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "
 * ...
 * inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value){
 * 		int mp = os::is_MP();
 * 		__asm__volatile (LOCK_IF_MP(%4)) "cmpxchgl %1,(%3)"
 * 				: "=a" (exchange_value)
 * 				: "r" (exchange_vluae), "a" (compare_value), "r" (dest), "r" (mp)
 * 				: "cc" , "memory");
 * 		return exchange_value;
 * }
 * 
 * "lock;"前缀实际上相当于是内存屏障，该内存屏障会为指令的执行提供如下几个保障。
 * 1.确保指令重排序时不会将其后面的代码排到内存屏障之前。
 * 2.确保指令重排序时不会将其前面的代码排到内存屏障之后。
 * 3.确保在执行到内存屏障修饰的指令时前面的代码全部执行完成。
 * 4.强制将线程工作内存中值的修改刷新至主内存中。
 * 5.如果是写操作，则会导致其它线程工作内存(CPU Cache)中的缓存数据失效。
 * 
 * 13.3.3 volatile的使用场景
 * 		虽然volatile有部分synchronized关键字的语义，但是volatile不可能完全替代synchronized关键字，
 * 因为volatile关键字不具备原子性操作语义，我们在使用volatile关键字的时候也是充分利用的可见性以及有序性（防止重排序）特点。
 * (1)开关控制利用可见性的特点
 * 	开关控制中最常见的就是进行线程的关闭操作。在3.9.1节中已经对其有过介绍，这里再简单回顾一下：
 * package com.lbq.concurrent.chapter13;

	import java.util.concurrent.TimeUnit;
	
	public class ThreadCloseable extends Thread {
		//volatile关键字保证了started线程的可见性
		private volatile boolean started = true;
		
		@Override
		public void run() {
			while(started) {
				try {
					TimeUnit.SECONDS.sleep(3);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("----------");
			}
		}
		
		public void shutdown() {
			this.started = false;
		}
		public static void main(String[] args) throws InterruptedException {
			ThreadCloseable t1 = new ThreadCloseable();
			t1.start();
			TimeUnit.SECONDS.sleep(15);
			t1.shutdown();
			System.out.println("++++++++++++++++");
		}
	
	}
 * 当外部线程执行ThreadCloseable的shutdown方法时，ThreadCloseable会立刻看到started发生了变化(原因是因为ThreadCloseable工作内存中的started失效了，不得不到主内存中重新获取)。
 * 如果started没有被volatile关键字修饰，那么很有可能外部线程在其工作内存中修改了started之后不及时刷新到主内存中，或者ThreadCloseable一直到自己的工作内存中读取started变量，
 * 都有可能导致started=true不生效，线程就会无法关闭。
 * (2)状态标记利用顺序性特点
 * 		关于使用状态标记说明顺序性的例子，我们之前用context进行过了举例，这里就不再赘述了。
 * (3)Singleton设计模式的double-check也是利用了顺序性特点
 * 		原本不打算在本书中介绍singleton设计模式的，但是笔者发现它与类的主动加载，以及在高并发情况下如何获取唯一实例且保持高效等内容息息相关，
 * 尤其是使用volatile关键字对double-check的改进，因此将singleton设计模式加入到本书并且将其作为第三部分的一个章节来讲解。
 * 
 * 13.3.4 volatile和synchronized
 * 		通过对volatile关键字的学习和之前对synchronized关键字的学习，我们在这里总结一下两者之间的区别。
 * (1)使用上的区别
 * 	1.volatile关键字只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量、常量等。
 * 	2.synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块。
 * 	3.volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null。
 * (2)对原子性的保证
 * 	1.volatile无法保证原子性
 * 	2.由于synchronized是一种排他的机制，因此被synchronized关键字修饰的同步代码是无法被中途打断的，因此其能够保证代码的原子性。
 * (3)对可见性的保证
 * 	1.两者均可以保证共享资源在多线程间的可见性，但是实现的机制完全不同。
 * 	2.synchronized借助于JVM指令monitor enter和monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中。
 * 	3.相比较于synchronized关键字，volatile使用机器指令(偏硬件)“lock;”的方式迫使其他线程工作内存中的数据失效，不得不到主内存中进行再次加载。
 * (4)对有序性的保证
 * 	1.volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以它能够保证有序性。
 * 	2.虽然synchronized关键字所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修饰的代码块中代码指令也会发生指令重排序的情况。
 * (5)其他
 * 	1.volatile不会使线程陷入阻塞。
 * 	2.synchronized关键字会使线程进入阻塞状态。
 * @author 14378
 *
 */
public class VolatileTest {
	//使用volatile修饰共享资源i
	private static volatile int i = 0;
	//使用在第23章中开发的CountDownLatch
	private static final CountDownLatch latch = new CountDownLatch(10);
	
	private static void inc() {
		i++;
	}
	public static void main(String[] args) throws InterruptedException {
		for(int i = 0; i < 10; i++) {
			new Thread(() -> {
				for(int x = 0; x < 1000; x++) {
					inc();
				}
				//使计数器减一
				latch.countDown();
			}).start();
		}
		//等待所有的线程完成工作
		latch.await();
		System.out.println(i);
	}

}
